
(defvar *cases* nil)

(setq *mutex-preds* '((next-time-step)))

(defun tracking-belief-conflict-test (pred b1 b2)
  (let ((args1 (rest (belief-content b1)))
        (args2 (rest (belief-content b2))))
    ;;(format t "Checking if (~A) ~A and ~A conflict...~%" pred args1 args2)
    ;;(format t "Mismatching? ~A~%" (not (null (mismatch args1 args2 :test #'agreeable-args?))))
    (and
     ;; first ensure these two beliefs aren't simply compatible or the same
     (not (null (mismatch args1 args2 :test #'agreeable-args?)))
     (cond ((equal pred 'obj-color)
            (destructuring-bind
                  (x1 y1 t1 c1 x2 y2 t2 c2) (append args1 args2)
              ;; same color (not skolem), same time (not skolem),
              ;; but different locations (not skolems)
              (and (not (skolem? c1))
                   (not (skolem? c2))
                   (equal c1 c2)
                   (not (skolem? t1))
                   (not (skolem? t2))
                   (equal t1 t2)
                   (or (and (not (skolem? x1))
                            (not (skolem? x2))
                            (not (equal x1 x2))))
                   (or (and (not (skolem? y1))
                            (not (skolem? y2))
                            (not (equal y1 y2)))))))
           ((equal pred 'mov)
            (destructuring-bind
                  (xa1 ya1 xa2 ya2 ta1 ta2 ca xb1 yb1 xb2 yb2 tb1 tb2 cb) (append args1 args2)
              (or
               ;; start at same place at same time (no splits allowed)
               (and (not (skolem? xa1))
                    (not (skolem? ya1))
                    (not (skolem? xb1))
                    (not (skolem? yb1))
                    (not (skolem? ta1))
                    (not (skolem? tb1))
                    (equal xa1 xb1)
                    (equal ya1 yb1)
                    (equal ta1 tb1))
               ;; end at same place at same time (no merges allowed)
               (and (not (skolem? xa2))
                    (not (skolem? ya2))
                    (not (skolem? xb2))
                    (not (skolem? yb2))
                    (not (skolem? ta1))
                    (not (skolem? tb1))
                    (equal xa2 xb2)
                    (equal ya2 yb2)
                    (equal ta1 tb1))
               ;; mov-b ends where mov-a starts but they're not the same color
               (and (not (skolem? xa1))
                    (not (skolem? ya1))
                    (not (skolem? xb2))
                    (not (skolem? yb2))
                    (not (skolem? ta1))
                    (not (skolem? tb1))
                    (not (skolem? ca))
                    (not (skolem? cb))
                    (equal xa1 xb2)
                    (equal ya1 yb2)
                    (equal ta1 tb2)
                    (not (equal ca cb)))
               ;; mov-a ends where mov-b starts but they're not the same color
               (and (not (skolem? xa2))
                    (not (skolem? ya2))
                    (not (skolem? xb1))
                    (not (skolem? yb1))
                    (not (skolem? ta1))
                    (not (skolem? tb1))
                    (not (skolem? ca))
                    (not (skolem? cb))
                    (equal xa2 xb1)
                    (equal ya2 yb1)
                    (equal ta2 tb1)
                    (not (equal ca cb)))
               ;; same color, same start-end times but not same
               ;; start-end locations (don't connect)
               (and (not (skolem? xa1))
                    (not (skolem? ya1))
                    (not (skolem? xa2))
                    (not (skolem? ya2))
                    (not (skolem? xb1))
                    (not (skolem? yb1))
                    (not (skolem? xb2))
                    (not (skolem? yb2))
                    (not (skolem? ta1))
                    (not (skolem? tb1))
                    (not (skolem? ca))
                    (not (skolem? cb))
                    (equal ca cb)
                    (or (and (equal ta2 tb1)
                             (or (not (equal xa2 xb1))
                                 (not (equal ya2 yb1))))
                        (and (equal ta1 tb2)
                             (or (not (equal xa1 xb2))
                                 (not (equal ya1 yb2))))))
               ;; same color, same movement time, but different
               ;; locations (same color can't be in two places at once)
               (and (not (skolem? xa1))
                    (not (skolem? ya1))
                    (not (skolem? xa2))
                    (not (skolem? ya2))
                    (not (skolem? xb1))
                    (not (skolem? yb1))
                    (not (skolem? xb2))
                    (not (skolem? yb2))
                    (not (skolem? ta1))
                    (not (skolem? tb1))
                    (not (skolem? ca))
                    (not (skolem? cb))
                    (equal ca cb)
                    (equal ta1 tb1)
                    (or (not (equal xa1 xb1))
                        (not (equal ya1 yb1))
                        (not (equal xa2 xb2))
                        (not (equal ya2 yb2)))))))
           ;; otherwise, the beliefs don't conflict
           (t nil)))))

(setq *belief-conflict-test* #'tracking-belief-conflict-test)

(defun test-ng (steps &optional (pb #'pick-belief-fewrules-unattached))
  (test-one steps *evidence* *rules* pb))

(defun inc-test-ng (steps &optional (plot? nil) (pb #'pick-belief-fewrules-unattached))
  ;; not a good idea to split in this rule set.
  (inc-test-one steps *evidence* *rules* plot? pb))

(defun test-all-exp-cases (steps &optional (pb #'pick-belief-fewrules-unattached) (print? nil))
  (test-exp-cases steps *cases* *rules* pb nil print?))

